import * as fs from 'fs';
import * as path from 'path';
import config from '#config';
import logger from '#drivers/logger';
import { ServiceResponse, SuccessResponse } from '#apiservices';
import { Response } from 'express';
import { OpenApiRequest } from 'express-openapi-validator/dist/framework/types';
import APIError, { WrapError } from '#drivers/api-error';
import httpStatus from 'http-status';

export default class Controller {
    static sendResponse(response: Response, payload: SuccessResponse) {
        /**
         * The default response-code is 200. We want to allow to change that. in That case,
         * payload will be an object consisting of a code and a payload. If not customized
         * send 200 and the payload as received in this method.
         */
        response.status(payload.statusCode || 200);
        const responsePayload = payload.payload !== undefined ? payload.payload : payload;
        if (responsePayload instanceof Object) {
            response.json(responsePayload);
        } else {
            response.end(responsePayload);
        }
    }

    static sendError(response: any, error: APIError | Error) {
        let apiErr: APIError = WrapError(error);
        logger.error(apiErr);
        response.status(apiErr.statusCode);
        response.json(apiErr);
    }
    

    /**
     * Files have been uploaded to the directory defined by config.js as upload directory
     * Files have a temporary name, that was saved as 'filename' of the file object that is
     * referenced in request.files array.
     * This method finds the file and changes it to the file name that was originally called
     * when it was uploaded. To prevent files from being overwritten, a timestamp is added between
     * the filename and its extension
     * @param request
     * @param fieldName
     * @returns {string}
     */
    //FIXME: What is this used for
    static collectFile(request: any, fieldName: any) {
        let uploadedFileName = '';
        if (request.files && request.files.length > 0) {
            const fileObject = request.files.find((file: any) => file.fieldname === fieldName);
            if (fileObject) {
                const fileArray = fileObject.originalname.split('.');
                const extension = fileArray.pop();
                fileArray.push(`_${Date.now()}`);
                uploadedFileName = `${fileArray.join('')}.${extension}`;
                fs.renameSync(
                    path.join(config.FILE_UPLOAD_PATH, fileObject.filename),
                    path.join(config.FILE_UPLOAD_PATH, uploadedFileName)
                );
            }
        }
        return uploadedFileName;
    }

    /*
    static getRequestBodyName(request: OpenApiRequest): string {
            const codeGenDefinedBodyName = request.openapi.schema['x-codegen-request-body-name'];
            if (codeGenDefinedBodyName !== undefined) {
                return codeGenDefinedBodyName;
            }
            const refObjectPath =
                request.openapi.schema.requestBody.content['application/json'].schema.$ref;
            if (refObjectPath !== undefined && refObjectPath.length > 0) {
                return refObjectPath.substr(refObjectPath.lastIndexOf('/') + 1);
            }
        return 'body';
    }
    */

    static collectRequestParams(request: any) {
        logger.debug('----- Request -----');
        //logger.debug(request);
        logger.debug('---- End of Request ----');
        const requestParams: { [key: string]: any } = {};

        if (request.openapi.schema.requestBody != null) {
            const { content } = request.openapi.schema.requestBody;
            if (content['application/json'] !== undefined) {
                const requestBodyName = 'body';
                requestParams[requestBodyName] = request.body;
            } else if (content['multipart/form-data'] !== undefined) {
                Object.keys(content['multipart/form-data'].schema.properties).forEach(
                    (property) => {
                        const propertyObject =
                            content['multipart/form-data'].schema.properties[property];
                        if (
                            propertyObject.format !== undefined &&
                            propertyObject.format === 'binary'
                        ) {
                            requestParams[property] = this.collectFile(request, property);
                        } else {
                            requestParams[property] = request.body[property];
                        }
                    }
                );
            }
        }

        if (request.openapi.schema.parameters != null) {
            request.openapi.schema.parameters.forEach((param: any) => {
                if (param.in === 'path') {
                    requestParams[param.name] = request.openapi.pathParams[param.name];
                } else if (param.in === 'query') {
                    requestParams[param.name] = request.query[param.name];
                } else if (param.in === 'header') {
                    requestParams[param.name] = request.headers[param.name];
                }
            });
        }

        logger.info('--- Request Params ---');
        logger.info(requestParams);
        logger.info('--- End of Request Params ----');
        return requestParams;
    }

    static async handleRequest(request: OpenApiRequest, response: Response, serviceOperation: any) {
        try {
            const serviceResponse: ServiceResponse = await serviceOperation(
                this.collectRequestParams(request)
            );
            Controller.sendResponse(response, <SuccessResponse>serviceResponse);
        } catch (error) {
            Controller.sendError(response, <APIError>error);
        }
    }
}
